[["index.html", "R Cheat Sheet 1 About", " R Cheat Sheet Koen 2024-01-03 1 About This book contains some useful snippets for using R. Large parts of this cheat sheet are based on the materials for the R for Social Science Data Carpentry Workshop "],["setting-up.html", "2 Setting up", " 2 Setting up Before starting, we need some sample data, and make sure out data folder is set up properly. The file we’re using is a simple CSV file we download using he download.file() function. We will also download the packages we need. Especially tidyverse which contains a large number of functions to make data management easier. dir.create(&quot;data&quot;) download.file( &quot;https://raw.githubusercontent.com/datacarpentry/r-socialsci/main/episodes/data/SAFI_clean.csv&quot;, &quot;data/SAFI_clean.csv&quot;, mode = &quot;wb&quot; ) install.packages(&quot;tidyverse&quot;) Then we load the file in R, using the read_csv() function from the tidyverse package library(tidyverse) interviews &lt;- read_csv(&quot;data/SAFI_clean.csv&quot;, na = &quot;NULL&quot;) "],["data-wrangling.html", "3 Data Wrangling 3.1 Basic Data Manipulation 3.2 Pivoting (or reshaping) 3.3 Joining (or merging) data 3.4 Summarizing over groups (or collapsing data) 3.5 Advanced Row Wise Operations", " 3 Data Wrangling 3.1 Basic Data Manipulation Below we do some basic data manipulations on our interview data. interviews %&gt;% filter(village == &quot;Chirodzo&quot;) %&gt;% mutate(people_per_room = no_membrs / rooms, day = day(interview_date), month = month(interview_date), year = year(interview_date)) %&gt;% select(key_ID:rooms, day:people_per_room, -village) %&gt;% filter(interview_date &gt; &quot;2016-12-1&quot; &amp; interview_date &lt; &#39;2017-01-01&#39;) ## # A tibble: 1 × 8 ## key_ID interview_date no_membrs years_liv respondent_wall_type rooms ## &lt;dbl&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 10 2016-12-16 00:00:00 12 23 burntbricks 5 ## # ℹ 2 more variables: day &lt;int&gt;, people_per_room &lt;dbl&gt; Note: We filter a number of rows using the filter() function We create some new variables using mutate. Note that for some date operations we use the lubridate library, wich is include in the tidyverse. Check out lubridate’s documentation for more advanced date manipulation techniques. We select some of our variables using select(); note that you can select a range of variables using varaible1:variable2 and drop variables using the -. We “chain” all these operations together using the pipe operator %&gt;%. 3.2 Pivoting (or reshaping) When you want to combine two data frames at different levels of analysis, for example a household roster with the rest of the household questionnaire, you’ll run into the problem that the household roster has more rows than the household questionnaire: the household roster will have each row repeated for each household member (i.e. it is long data). To combine it with the household data data we need to make sure the columns are repeated for each member (ie make the data wide). In R, this is done using the pivot_wider() function, which works much like Stata’s reshape command. 3.2.1 Creating fake data First, let’s create some long data, so we have something to pivot. We will make sure that our household roster has a number of lines for each household that is equal to the household size, and has two randomly generated variables: female and age. long_data &lt;- interviews %&gt;% select(key_ID,no_membrs ) %&gt;% uncount(no_membrs) %&gt;% group_by(key_ID) %&gt;% mutate(member_ID = row_number()) %&gt;% rowwise() %&gt;% mutate(female = sample(0:1,1), age = case_when(member_ID == 1 ~ sample(18:86,1), .default = sample(0:86,1))) %&gt;% ungroup() long_data ## # A tibble: 942 × 4 ## key_ID member_ID female age ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 1 86 ## 2 1 2 0 36 ## 3 1 3 1 56 ## 4 2 1 0 37 ## 5 2 2 0 0 ## 6 2 3 0 38 ## 7 2 4 0 18 ## 8 2 5 0 53 ## 9 2 6 1 26 ## 10 2 7 0 6 ## # ℹ 932 more rows Note that this uses some advanced data wrangling: uncount() to inflate each number of rows by the number of members in the household. group_by(key_ID) and row_number() to generate the row number within all observations with the same key_ID. rowwise() to ensure randomizations are run over each row, rather than once for the entire data set. sample() to get random integers. case_when() to make sure the age is never lower than 18 if the member_id is 1 (presumably the household head). 3.2.2 Pivoting long to wide To merge this into our main data set, we need to make sure we go back to having 1 observation per household. We will do this by using pivot_wider(): wide_data &lt;- long_data %&gt;% pivot_wider(names_from = member_ID, values_from = !ends_with(&quot;_ID&quot;)) wide_data ## # A tibble: 131 × 39 ## key_ID female_1 female_2 female_3 female_4 female_5 female_6 female_7 ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 0 1 NA NA NA NA ## 2 2 0 0 0 0 0 1 0 ## 3 3 0 0 0 0 0 0 1 ## 4 4 0 1 0 1 1 1 1 ## 5 5 1 0 1 1 0 1 0 ## 6 6 0 0 1 NA NA NA NA ## 7 7 1 0 1 0 1 0 NA ## 8 8 0 0 0 1 0 0 0 ## 9 9 0 0 0 0 0 0 0 ## 10 10 1 0 0 1 1 0 1 ## # ℹ 121 more rows ## # ℹ 31 more variables: female_8 &lt;int&gt;, female_9 &lt;int&gt;, female_10 &lt;int&gt;, ## # female_11 &lt;int&gt;, female_12 &lt;int&gt;, female_13 &lt;int&gt;, female_14 &lt;int&gt;, ## # female_15 &lt;int&gt;, female_16 &lt;int&gt;, female_17 &lt;int&gt;, female_18 &lt;int&gt;, ## # female_19 &lt;int&gt;, age_1 &lt;int&gt;, age_2 &lt;int&gt;, age_3 &lt;int&gt;, age_4 &lt;int&gt;, ## # age_5 &lt;int&gt;, age_6 &lt;int&gt;, age_7 &lt;int&gt;, age_8 &lt;int&gt;, age_9 &lt;int&gt;, ## # age_10 &lt;int&gt;, age_11 &lt;int&gt;, age_12 &lt;int&gt;, age_13 &lt;int&gt;, age_14 &lt;int&gt;, … We only needed to specify two options: names_from: this is the column that contains the names (or usually numbers) for each of our units of analysis. In this case, the member_ID. values_from: the variables containing the data. All variables you specify here, will get one column for each possible value of names_from. In our case, these variables female and age. I used tidy select syntax to specify all variables except the ones ending in “_ID”. pivot_wider() will assume all variables not specified in names_from and values_from are the unique identifiers of your wide data. In our case, the only remaining variable is key_ID, which is indeed the unique identifier. 3.2.3 Pivoting wide to long If we had started with wide data, and had wanted to transform to long data, we’d have to use pivot_longer(): recreated_long_data &lt;- wide_data %&gt;% pivot_longer(!key_ID, names_to = c(&quot;.value&quot;, &quot;member_ID&quot;), names_sep=&quot;_&quot;, values_drop_na = TRUE) long_data ## # A tibble: 942 × 4 ## key_ID member_ID female age ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 1 1 86 ## 2 1 2 0 36 ## 3 1 3 1 56 ## 4 2 1 0 37 ## 5 2 2 0 0 ## 6 2 3 0 38 ## 7 2 4 0 18 ## 8 2 5 0 53 ## 9 2 6 1 26 ## 10 2 7 0 6 ## # ℹ 932 more rows In this case, the syntax is a bit harder to understand than that of pivot wider. It’s good to think first what the original data looks like, and how we intend to transform it. The wide data has columns key_ID, age_1-19 and female_1-19. We don’t really want to touch the key_ID column. We want to turn the columns age_1-19 and female_1-19 into three columns: female, age and Member_ID, which contains the values 1-19. This translates to the options we passed to pivot_longer() as follows: !key_ID: We want to pivot the data that’s in all columns except key_ID. names_to = c(\".value\", \"member_ID\"): this specifies the new columns we want to create. It basically says that the existing column names consist of two parts: one part (i.e. female and age) that we wish to keep as column names , and one part (i.e. the numbers 1-19) which should be put into a new column which we will “member_ID”. \"names_sep=\": this indicates how the two parts mentioned above are separated. If there is no separator (for example your variables are called age1, age2, etc.) you’ll have to use thenames_pattern option. values_drop_na = TRUE: tells R to drop rows that have missing data for all variables. If we had set this to FALSE, we’d have 19 rows for each household, with a lot of missing data in all households smaller than 19 people. 3.3 Joining (or merging) data Tidyverse has four functions to join (or merge, as Stata calls it) two data sets. The functions that differ in the way they treat observations that are in one data set but not the other. Consider the diagram below. It has two data sets, x (in Stata terms, this is the master data set) and y (the using data set in Stata terms). They have overlapping rows (area B), but also rows that are only in x (area A) or only in y (area C). The four join functions work as follows: inner_join() will only keep area B. left_join() will keep areas A and B. right_join() will keep areas B and C. full_join() will keep areas A, B, and C. In our case, the data sets match perfectly, i.e. we only have an area B, so there is no practical difference. I chose left_join() so the number of observations in my household survey is guaranteed to remain the same. To merge the roster to the household data, we use the join_by function: interviews %&gt;% left_join(wide_data) ## # A tibble: 131 × 52 ## key_ID village interview_date no_membrs years_liv respondent_wall_type ## &lt;dbl&gt; &lt;chr&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 God 2016-11-17 00:00:00 3 4 muddaub ## 2 2 God 2016-11-17 00:00:00 7 9 muddaub ## 3 3 God 2016-11-17 00:00:00 10 15 burntbricks ## 4 4 God 2016-11-17 00:00:00 7 6 burntbricks ## 5 5 God 2016-11-17 00:00:00 7 40 burntbricks ## 6 6 God 2016-11-17 00:00:00 3 3 muddaub ## 7 7 God 2016-11-17 00:00:00 6 38 muddaub ## 8 8 Chirodzo 2016-11-16 00:00:00 12 70 burntbricks ## 9 9 Chirodzo 2016-11-16 00:00:00 8 6 burntbricks ## 10 10 Chirodzo 2016-12-16 00:00:00 12 23 burntbricks ## # ℹ 121 more rows ## # ℹ 46 more variables: rooms &lt;dbl&gt;, memb_assoc &lt;chr&gt;, affect_conflicts &lt;chr&gt;, ## # liv_count &lt;dbl&gt;, items_owned &lt;chr&gt;, no_meals &lt;dbl&gt;, months_lack_food &lt;chr&gt;, ## # instanceID &lt;chr&gt;, female_1 &lt;int&gt;, female_2 &lt;int&gt;, female_3 &lt;int&gt;, ## # female_4 &lt;int&gt;, female_5 &lt;int&gt;, female_6 &lt;int&gt;, female_7 &lt;int&gt;, ## # female_8 &lt;int&gt;, female_9 &lt;int&gt;, female_10 &lt;int&gt;, female_11 &lt;int&gt;, ## # female_12 &lt;int&gt;, female_13 &lt;int&gt;, female_14 &lt;int&gt;, female_15 &lt;int&gt;, … Note that we didn’t specify identifiers, like we would in Stata. R assumed that the variables that appear in both data frames are the identifiers, in this case key_ID. Use the by option to change this. Going the other way around, joining the household data to the roster data, is equally easy: long_data %&gt;% left_join( interviews %&gt;% select(key_ID,village,interview_date)) ## # A tibble: 942 × 6 ## key_ID member_ID female age village interview_date ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;dttm&gt; ## 1 1 1 1 86 God 2016-11-17 00:00:00 ## 2 1 2 0 36 God 2016-11-17 00:00:00 ## 3 1 3 1 56 God 2016-11-17 00:00:00 ## 4 2 1 0 37 God 2016-11-17 00:00:00 ## 5 2 2 0 0 God 2016-11-17 00:00:00 ## 6 2 3 0 38 God 2016-11-17 00:00:00 ## 7 2 4 0 18 God 2016-11-17 00:00:00 ## 8 2 5 0 53 God 2016-11-17 00:00:00 ## 9 2 6 1 26 God 2016-11-17 00:00:00 ## 10 2 7 0 6 God 2016-11-17 00:00:00 ## # ℹ 932 more rows Note that here I only merged in two variables, by using select and a pipe within the left_join() function. 3.4 Summarizing over groups (or collapsing data) To compute summary statistics (sums, counts, means etc.) over a group, we use the group_by() and summarize() functions. For example, to compute the household size, number of women and average age in each household: long_data %&gt;% group_by(key_ID) %&gt;% summarize(hh_size = n(), num_women = sum(female), mean_age = mean(age)) ## # A tibble: 131 × 4 ## key_ID hh_size num_women mean_age ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 3 2 59.3 ## 2 2 7 1 25.4 ## 3 3 10 2 34.7 ## 4 4 7 5 38.7 ## 5 5 7 4 48.9 ## 6 6 3 1 23.3 ## 7 7 6 3 61.3 ## 8 8 12 3 32.1 ## 9 9 8 0 33.2 ## 10 10 12 9 35.8 ## # ℹ 121 more rows 3.5 Advanced Row Wise Operations Suppose we wanted to get the above information (the household size, number of women and average age in each) from the wide data. The easiest, and probably best, way to do this in R is by reshaping to long, and do the above. But in Stata you would probably use some sort of egen function, and you can do similar things in R. It’s just a bit more complex: wide_data %&gt;% rowwise() %&gt;% mutate(mean_age = mean(c_across(starts_with(&quot;age_&quot;)), na.rm=TRUE), num_women = sum(c_across(starts_with(&quot;female_&quot;)), na.rm=TRUE), hh_size = sum(!is.na(c_across(starts_with(&quot;female_&quot;))), na.rm=TRUE)) %&gt;% select(key_ID,hh_size,num_women,mean_age) %&gt;% ungroup() ## # A tibble: 131 × 4 ## key_ID hh_size num_women mean_age ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 3 2 59.3 ## 2 2 7 1 25.4 ## 3 3 10 2 34.7 ## 4 4 7 5 38.7 ## 5 5 7 4 48.9 ## 6 6 3 1 23.3 ## 7 7 6 3 61.3 ## 8 8 12 3 32.1 ## 9 9 8 0 33.2 ## 10 10 12 9 35.8 ## # ℹ 121 more rows The key trick here is the combination of rowwise() and c_across(). rowwise() ensure all summaries are computed per row, and c_across() allows you to use tidy select syntax within the mean() and sum() functions. sum(!is.na()) simply counts the non-missing values. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
