# Programming with R {#functions}

You can improve your R code by using programming features such as 
loops and functions to make your code reusable. This prevents errors, 
while saving you time.


## Loops

Loops repeat code a number of time, they have the following structure:


```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

for (i in 1:4){
	print(i)
}

```

The `i` is the iterator, and each iteration of the loop it takes on the value of
a different element of the object that follows the `in`; in this case, `i` takes 
on 1,2,3 and finally 4 as its values. Therefore, this code is equivalent to:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

print(1)
print(2)
print(3)
print(4)

```

But it's much easier to maintain!

In general, most R programmers prefer not to use loops, but instead use functions
such as `lapply()` and `map()`. However, loops can be a perfectly fine way of 
doing repeated work.

## Functions

### Basic Functions

A function is an R object that takes an input (or argument) and returns something.
The argument is always provided within parentheses. The  `sqrt()` functions, for 
example, takes a number as its argument and returns the square root.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

sqrt(4)

```

The beauty of functions is that they allow you to define a set of operations in one place, and re-use it as often as you want. If you then need to update the
operations, all you need to do is update the function, instead of hunting down 
every instance of the operations throughout your script.

Take for example the following code that cleans missing data.


```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

#define an example variable
variable1 = c(1,2,3,-99,5,6)


#change missing
variable1_cleaned = if_else(variable1 == -99, NA,variable1)

variable1_cleaned 


```

This works, but I need to do this at many different places in my code, and 
it's easy to make typos. It's better to wrap this in a function:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

clean_missing <- function(input_data) {

	returned_data <- if_else(input_data == -99, NA, input_data)
	
	return(returned_data)
}


```

Here I've pretty much copied the code I had above, but made sure the argument
of the function has a name (defined in the parenteses after function) that makes sense. 

I can now just use the `clean_data()` wherever I want:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

clean_missing(variable1)

```

Note that any variables we created in the function are kept within the function, and you can't access them later:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

variable1_clean <- clean_missing(variable1)
returned_data

```

This keeps your working environment nice and clean, which again prevents problems.

### Functions and the tidyverse

In the previous function I passed a vector to clean, what if want to use it
in a data cleaning pipe? 

It's useful to start with the code without a function, and then to generalize
from there:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}


data_frame <- tibble(variable1 = variable1)

data_frame %>%
	mutate(variable1 = if_else(variable1 == -99,NA,variable1))



```

Let's try to put that in a function. The function will need to take 
a data frame and a variable name as its arguments:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}


clean_missing_df <- function(input_dataframe, variablename){
	returned_data <- 
		input_dataframe %>%
		mutate(variablename = variablename + 1)

	return(returned_data)
}


data_frame %>%
clean_missing_df(variable1)


```


## Basic structure

```{r eval=TRUE,echo=TRUE,warning=TRUE,error=TRUE,message=TRUE}

add_two <- function(argument) {
	# Do something with the input
	return <- argument + 2

	#call the intended output in the last line
	return
}

add_two(84)

```

## Using functions in a pipe

By default, a function in a pipe uses the dataset of the pipe as its first argument.
Also make sure to include a quick description of what your function does.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}
library(tidyverse)

add_number_column <- function(data,number=2) {
	#This functions takes a data frame, and returns the same data frame,
	#but with an exta column of 2sas its first variable. 
	#The user can specify a number other than 2 using the num argument
	#This is great if you want a column of twos as the first variable
	#of your data set.
	data %>%
		mutate(bestvar = number) %>%
		select(bestvar,everything())
}

read_csv(here("data/SAFI_clean.csv"),na = "NULL") %>%
add_number_column() 

read_csv(here("data/SAFI_clean.csv"),na = "NULL") %>%
add_number_column(4) 

```

## Passing variables to a function

The following doesn't work, because R can't find `no_membrs`, even though it 
does exist in the data set in the pipe.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=TRUE}

add_two_to_a_column_broken <- function(data,variable) {
	#function that wants to add two two a column specified by the user
	#but it doesn't work.
	data %>%
	mutate(variable = variable + 2)
}

read_csv(here("data/SAFI_clean.csv"),na = "NULL") %>%
add_two_to_a_column_broken(no_membrs) 

```

For a technical note on why this is, 
see [here](https://dplyr.tidyverse.org/articles/programming.html).
To solve this, wrap the variable in your function definition
in `{{` and `}}`, and change the `=` in `mutatate` to `:=`. 


```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

add_two_to_a_column_fixed <- function(data,variable) {
	#function that adds two two a column specified by the user
	data %>%
	mutate( {{variable}} := {{variable}} + 2)
}

read_csv(here("data/SAFI_clean.csv"),na = "NULL") %>%
	add_two_to_a_column_fixed(no_membrs)

```

## Function to create dummies from text

Remember our code to generate dummies based on text:

```{r eval=TRUE,echo=TRUE,warning=TRUE,error=TRUE,message=TRUE}

read_csv("data/SAFI_clean.csv", na = "NULL") %>%
    mutate(items_owned = ifelse(is.na(items_owned),"None",items_owned)) %>%
    select(key_ID,items_owned) %>%
    separate_longer_delim(items_owned, delim = ";") %>%
    mutate(value = 1) %>%
    pivot_wider(names_from = items_owned,
                values_from = value,
                names_prefix = "owns_",
                values_fill = 0) 

```

I now want to apply this same principle to `months_lack_food` column.
I could copy-paste the code, but the better solution is to make a function:

```{r eval=TRUE,echo=TRUE,warning=TRUE,error=TRUE,message=TRUE}


create_dummies <- function(df,stringvar,prefix="",delim = ";") {
	#Function that generates dummies from a string variable
	#containing multi-response answers
	#returns dataset without original var, but with dummies.

	df %>%
		separate_longer_delim({{stringvar}}, delim = delim) %>%
	    mutate(value = 1) %>%
        pivot_wider(names_from = {{stringvar}},
                    values_from = value,
                    names_prefix = prefix,
                    values_fill = 0) 
}

read_csv(here("data/SAFI_clean.csv"), na = "NULL") %>%
	mutate(items_owned = ifelse(is.na(items_owned),"None",items_owned)) %>%
	create_dummies(stringvar = items_owned, prefix = "owns_") %>%
	create_dummies(months_lack_food,"lack_food_")

```

The code is now clear, I can update the function in one place and all variables will
be updated accordingly. Plus, if I want to use the same code in another project, I can
easily do it. 