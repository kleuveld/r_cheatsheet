# Power Analysis using DeclareDesign

[DeclareDesign](https://declaredesign.org/) is a system to simulate Research Designs. This is useful for power 
analysis, because it is often hard to include things like clustering and 
covariates in standard power calculators. 

Resources for learning about DeclareDesign:

- [Slides by the authors of DeclareDesign: Graeme Blair, Alex Coppock, Macartan Humphreys](https://macartan.github.io/slides/202211_declaredesign_and_power.html)
- [The DeclareDesign CheatSheet](https://raw.githubusercontent.com/rstudio/cheatsheets/master/declaredesign.pdf)
-  The book [Research Design in the Social Sciences: Declaration, Diagnosis, and Redesign](https://book.declaredesign.org/)

Read at least the slides before going forward!

## Diff-in-Diff

Here's a common situation: I've collected some baseline data, and are 
wondering if our study has sufficient power to pick up expected treatment
effects.

I will start off with some fake baseline data, which only contains `y0`, our outcome
indicator. We use the `fabricate()` function, from the fabricatr library, which is
loaded with DeclareDesign:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

library(tidyverse)
library(DeclareDesign)

rm(list=ls())
set.seed(1)


N = 100

fake_data <-
  fabricate(N = N, 
            y0 = runif(N, 100, 150))

fake_data %>% as_tibble()

```

Now, let's add an extra year to our data, again using `fabricate()`, just
to demonstrate how, using `add_level()` and  then `crosslevels()`:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

fakedata_years <-
  fabricate(fake_data,
            years = add_level(N = 2, t = as.numeric(years) - 1, nest=FALSE),
            observations = cross_levels(by = join_using(ID, years)))

fakedata_years %>% as_tibble()


```

Now it's time to start declaring our design. The first element of the 
design is the model, which essentially is my data, and I declare it 
using the same synytax as `fabricate()`
above. This means you can input existing data, but also generate 
random new variables.

The potential outcomes are generated using the `potential_outcomes()`.
This will create two variables `Y_Z_1` and `Y_Z_0`, which are 
the potential outcomes if assigned to treatment (`Z == 1`) or not.

You can see I have created a very simple data generating 
process to generate different outcomes in `t = 1` for treatment 
and control, but you can go absolutely wild here to check the 
assumptions you have: you can cluster the outcomes, include 
compliance or treatment effectiveness, add more or less noise, 
make it depend on  both observable and unobservable 
characteristics, etc. etc.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

year_shock <- 10
effect_size <- 15
sd <- 5

model <- 
  declare_model(fakedata_years,
                potential_outcomes(Y ~ y0 + t * year_shock + 
                                            t * Z * effect_size + 
                                            t * rnorm(N,sd = sd)))

```

Then it's time to think about assignment. I need to assign treatment, 
and reveal the outcomes based on treatment assignment. 
If treatment had already been known during baseline (not
unlikely) then we would have only had to reveal the outcomes:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

assignment <-
  declare_assignment(group = cluster_ra(clusters = ID, prob = 0.5),
                     Z = ifelse(group == 1 & t == 1,1,0),
                     Y = reveal_outcomes(Y ~ Z)) 
```

Next, I declare my theoretical quantity of interest is the treatment 
effect in year 1. This is useful to check for bias. This is not really
needed here, since my model will follow our data generation process exactly,
so I could have just skipped this step.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

inquiry <-  
  declare_inquiry(ATE = mean(Y_Z_1 - Y_Z_0), subset = (t == 1)) 
  #declare_inquiry(ATE = mean(Y_Z_1 - Y_Z_0))
````

And finally the estimator with which I hope to estimate the ATE:

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

estimator <-
  declare_estimator(Y ~ t + Z, inquiry = "ATE", .method = lm_robust, term = "Z", label = "DiD")

```

Finally, I combine all these elements to declare my design. Note that 
it's only here that R starts actually running the code to randomize 
things. The previous was just declaration!

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}
  
  design <- model + assignment + inquiry + estimator 
  summary(design)

```

If you want to browse a version of the data created by your design,
use the `draw_data()` function. This is useful to examine the properties of the data.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

  draw_data(design) %>%
  head()

```

Now to calculate our power. The `diagnose_design()` will run our
model 500 times and our power is simply the fraction of times we
find a statistically significant effect.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

  diagnose_design(design)

```

Looks good! But what if we were too optimistic? We can vary various 
parameters of our design, and test all combinations by using the 
`redesign()` function. Here I check a few plausible values for 
our `year_shock` variable and the expected effect size.

I've set the `sims` option of `diagnose_design()` to 100, to reduce
the number of times each variation of the model is run to save me
some time.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

set.seed(1234)

diagnosis <-
  design %>%
  redesign(effect_size = 6:15,
           year_shock = c(10,15,20)) %>%
  diagnose_design(sims = 100)

```

Now, I want a nice plot. For this I use the
`tidy()` function to convert the output to a data frame, which 
I then pipe into `ggplot()`. It's now easy to see that I should 
be able to pick up an effect size of 9 in most cases.

```{r eval=TRUE, include = TRUE, echo=TRUE, warning=TRUE, error=TRUE, message=FALSE}

diagnosis %>%
  tidy() %>%
  filter(diagnosand == "power") %>%
  select(effect_size,year_shock,power = estimate) %>%
  mutate(year_shock = as.factor(year_shock)) %>%
  ggplot(aes(x = effect_size, y = power, 
             group=year_shock, color=year_shock)) +
    geom_line() +
    geom_hline(yintercept=0.8,linetype=2) + 
    scale_x_continuous(breaks=seq(6,16,2))

```


